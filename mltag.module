<?php

/**
 * Implements hook_help().
 */
function mltag_help($path, $arg) {
  $output = '';
  switch ($path) {
    case "admin/help#mltag":
      $output = t('A module to populate Tags for content using Machine Learning Algorithms - a GSOC 2012 project');
      break;
  }
  return $output;
}
/**
 * Implementation of hook_form_alter()
 */
function mltag_form_alter(&$form, &$form_state, $form_id) {
  drupal_set_message(check_plain($form_id));
  $bundles = variable_get('mltag_node_types', array('article'));
  if (isset($form['type']) && $form['type']['#value'] . '_node_form' == $form_id && in_array($form['type']['#value'], $bundles, TRUE)) {
    
      
   $form['mltag_new'] = array(
      '#type' => 'fieldset',
      '#title' => t('MLTag settings'),
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,
      '#group' => 'additional_settings',
      '#tree' => TRUE,
      '#weight' => -2,
      '#attached' => array(
         // 'js' => array('vertical-tabs' => drupal_get_path('module', 'vertical_tabs_example') . '/vertical_tabs_example.js',
       ), 
      '#attributes' => array('class' => array('mltag-settings')),
    );
    
    $form['mltag_new']['tag'] = array(
        '#type' => 'button',
        '#value' => t("Suggest Tags"),
        '#ajax' => array(
            'callback' => 'mltag_suggest_tags_ajax',
            'wrapper' => 'mltag_suggest_tags_table_div',
            'effect' => 'slide',
            ),
    );
    /*
    $form['mltag_new']['sample_text'] = array(
      '#prefix' => '<div id="mltag_suggest_tags_markup_div">',
      '#suffix' => '</div>',
      '#markup' => t('Your Tags will appear here'),
      );
    */
   
   
    $header = array(
        'tag' => t('Tags'),
        'chi' => t('Chi square value'),
    );
    $form['mltag_new']['myselector'] = array(
        '#prefix' => '<div id="mltag_suggest_tags_table_div">',
        '#suffix' => '</div>',
       // '#markup' => t('Your tags will appear here'),
    );
    
    $form['mltag_new']['myselector']['implicit_tags'] = array(
        '#type' => 'tableselect',
        '#title' => 'My Selector',
        '#header' => $header,
        //'#attribute' => array('style' => 'display:none;'),           
    );
    
    $header_learn_tags = array(
        'sno ' => t('S. No.'),
        'tags' => t('Tags'),
    );
    
    $form['mltag_new']['myselector']['learn_tags'] = array(
        '#type' => 'tableselect',
        '#title' => 'Tags from Learning',
        '#header' => $header_learn_tags,
        //'#attribute' => array('style' => 'display:none;'),
    );
    $header_test = array(
        'sno' => 'sno',
        'tags' => 'tags',
        );
    $options_test["test1"] = array(
        'sno' => 'me',
        'tags' => 'you',
        );
    $options_test["test2"] = array(
        'sno' => 'me2',
        'tags' => 'you2',
    );
     
   
    $form['mltag_new']['test_table'] = array(
        '#type' => 'tableselect',
        '#title' => 'Test',
        '#header' => $header_test,
        '#options' => $options_test,
        //'#attribute' => array('style' => 'display:none;'),
    );
    $form['#attached']['css'] = array(
        drupal_get_path('module', 'mltag') . '/css/tableselect.css',
    );
   
    //return $form;
    unset($form_state['input']['myselector']['learn_tags']);
    unset($form_state['input']['myselector']['implicit_tags']);
    $form['#submit'][] = 'mltag_custom_submit_function';
  }// if ends
  
}// function ends


/**
 * Implements ajax callback function on press of button
 * in node add/edit content form
 * @todo checkbox for proposing learned tags only when it is checked
 */
function mltag_suggest_tags_ajax($form, &$form_state) {
  
  $output = '';
  $values = $form_state['values'];
  $title = $values['title'];
  $body = '';
  foreach ($values['body'][$values['language']] as $info) {
    $body .= $info['value'];
  }
  
  $content = check_plain($title) . ' ' . $body;
  if (trim($content) == '' || trim($content) == NULL) {
    $form['mltag_new']['myselector']['#markup'] = t('No content to generate Tags !');
    return $form['mltag_new']['myselector'];
  } 
  //pass the content to main tagging algorithm
  include_once 'includes/content_tag.inc';
  $tags = mltag_content_tag($content, variable_get('algo_type'), 20);
  //drupal_set_message(print_r($tags, TRUE));
  
  if (empty($tags)) {
    $output .= t('Content is insufficient to generate Tags using this algorithm. <br>Please choose other algorithm from Settings Page.');
    $form['mltag_new']['myselector']['#markup'] = $output;
    return $form['mltag_new']['myselector'];
  }
  else {
    $algo = variable_get('algo_type');
    if ($algo == 1) {
      $header = array(
          'tag' => t('Tag'),
          'frequency' => t('Frequency'), 
          );
      
      $options = array();      
      foreach ($tags as $key => $value) {
        $options[$key] = array(
            'tag' => $key,
            'frequency' => $value,
            );
      }    
    }
    
    elseif ($algo == 2) {
      $header = array(
          'tag' => t('Tag'),
          'chi' => t('Chi Square Value'), 
          );
    
      $options = array();
      foreach ($tags as $key => $value) {
        $options["$key"] = array(
            'tag' => "$key",
            'chi' => "$value",
        ); 
      } 
     
      //drupal_set_message(print_r($options, TRUE));
    }

    
   //call the 3rd algo that uses the learned model for proposing tags and display in another table
 
  if (variable_get('enable_learning') == TRUE) {
    
    $tags_from_learning = mltag_content_tag($content, 3);
   
    if (empty($tags_from_learning)) {
      $output .= t("No Tags based on learning were found..<br>This happens if MLTag could not find any relation between new and existing content<br> Or if you have not Trained your model recently<br><b><u>Suggestion</u></b>- Please keep your model Trained up-to-date");
      $form['mltag_new']['sample_text']['#markup'] = $output;
      return $form['mltag_new']['sample_text'];
    }
    else {
      
      $header_learn_tags = array(
        'sno' => t('S. No.'),
        'tags' => t('Tags'),
          );
      
      $options_learn = array();      
      foreach ($tags_from_learning as $key => $value) {
        $options_learn["$key"] = array(
            'sno' => "$key",
            'tags' => "$value",
        );                   
      }
    }
  } 
 /*
   
    $options_learn["0"] = array(
        'sno' => 'arjun',
        'tags' => 'says hi',
        ); */
        
  $form['mltag_new']['myselector']['implicit_tags']['#header'] = $header; 
  $form['mltag_new']['myselector']['implicit_tags']['#options'] = $options;
  $form['mltag_new']['myselector']['implicit_tags'] = form_process_tableselect($form['mltag_new']['myselector']['implicit_tags']);
  
  $form['mltag_new']['myselector']['learn_tags']['#header'] = $header_learn_tags;
  $form['mltag_new']['myselector']['learn_tags']['#options'] = $options_learn;
  $form['mltag_new']['myselector']['learn_tags'] = form_process_tableselect($form['mltag_new']['myselector']['learn_tags']);
  
  return $form['mltag_new']['myselector'];
  }
}

/**
 * @todo - if limit of 10 tags not met then call another algorithm
 * @todo - perform only if mltag learning is enabled ;
 * insert record in database only if implicit tag count >5
 * @todo - capture $user_tags from tags field by checkboxes and also those in tags textbox(if filled)
 * get all terms and their chi values from dbs, recalculate their z-score and insert it into
 * the text file.
 */

 function mltag_custom_submit_function($form, &$form_state) {
    //store the selected vocabulary from the table select in the database
    $selected_uids = $form_state['values']['mltag_new']['myselector']['implicit_tags'];
    drupal_set_message(print_r($form_state['values'], TRUE));
    drupal_set_message(print_r("hello", TRUE));
    
    $file = drupal_get_path("module", "mltag") . '/includes/test.txt';
    file_put_contents($file, urlencode(serialize($selected_uids)));
    //mltag_save_terms();
    $values = $form_state['values'];
    $title = $values['title'];
    $body = '';
    foreach ($values['body'][$values['language']] as $info) {
      $body .= $info['value'];
    }
    $content = check_plain($title) . ' ' . $body;
    include_once 'includes/content_tag.inc';
    $tags = mltag_content_tag($content, 2, 10);
    
    if($tags > 5) {
      
      $timestamp = date('Y-m-d G:i:s');
      $nid = $form_state['nid'];
      //$user_tags =
      db_merge('mltag_learn_tags')
      ->key(array('nid' => '10' ))
      ->fields(array('content_tags' => serialize($selected_uids), 'date_created' => $timestamp))
      ->execute();
      /*
      $result = db_query("select nid, content_tags from {mltag_learn_tags}");
      $tags_learned = array();
      while ($record = $result->fetchObject()) {
        $tags_learned["$record->nid"] = unserialize($record->content_tags);
      }
      
      foreach ($tags_learned as $nid => $array) {
        
         $tags_learned_array = mltag_merge_array($tags_learned_array, $array);
      }
      //drupal_set_message(print_r($tags_learned_array, TRUE));
       
      $sum = 0;
        
      foreach ($tags_learned_array as $word => $chi) {
        $sum += $chi;
      }
      
      $mean = $sum / count($tags_learned_array);
      $sd = mltag_sd($tags_learned_array);
      $ranked_tags = array();
      foreach ($tags_learned_array as $word => $chi) {
        $ranked_tags["$word"] = round((($chi - $mean) / $sd), 4);
      }
      
      arsort($ranked_tags);
      //$ranked_tags contains tags ranked using z-score
      $file = drupal_get_path("module", "mltag") . '/includes/learned_tags.txt';
      file_put_contents($file, urlencode(serialize($ranked_tags)));
      
    */
    }//if ends

}
function mltag_save_terms() {
  
}

/**
 * Implements hook_menu().
 */
function mltag_menu() {
  $items = array();
  
  $items['admin/config/mltag'] = array(
      'title' => 'MLTag Configuration Center',
      'description' => 'Settings for MLTag module',
      'position' =>  'left',
      'weight' => -100,
      'page callback' => 'system_admin_menu_block_page',
      'access arguments' => array('administer site configuration'),
      'file' => 'system.admin.inc',
      'file path' => drupal_get_path('module', 'system'),
  );
         
  $items['admin/config/mltag/settings'] = array(
    'title' => 'MLtag Settings',
    'description' => 'Change General settings of MLTag',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mltag_general_settings'),
    'type' => MENU_NORMAL_ITEM,
    'access arguments' => array('administer site configuration'),  
  );
  $items['admin/config/mltag/stopwords'] = array(
      'title' => 'MLtag Stopwords',
      'description' => 'Alter StopWords used while parsing',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('mltag_stopwords_settings'),
      'type' => MENU_NORMAL_ITEM,
      'access arguments' => array('administer site configuration'),
  );
  $items['admin/config/mltag/train'] = array(
      'title' => 'MLTag Train Model',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('mltag_configure_train_confirm'),
      'access arguments' => array('administer site configuration'),
      'type' => MENU_CALLBACK,      
      );
  
  return $items;
}


 /**
 * Implements mltag general settings form().
 */

function mltag_general_settings() {
  $result = db_query("select date_created from {mltag_learn_tags}");
  $record = $result->fetchObject();
  $num_rows = $result->rowCount();
  $form['algo_type'] = array(
      '#type' => 'select',
      '#default_value' => variable_get('algo_type', 2),
      '#title' => 'Algorithm',
      '#options' => array(
          1 => 'Term Frequency',
          2 => 'Word Co-occurrence Statistical Algorithm',
      ),
      '#description' => t('Choose an algorithm'),
  );
  
   
  $form['enable_learning'] = array( 
      '#type' => 'checkbox',
      '#title' => t('Enable Learning algorithm'),
      '#default_value' => variable_get('enable_learning', TRUE),
      );
  
  $form['mytextcontainer'] = array(
          '#type' => 'container',
          '#states' => array(
              "visible" => array(
                  "input[name='enable_learning']" => array("checked" => TRUE)),
  ),
  );
  
  $form['mytextcontainer']['train'] = array(
      '#type' => 'submit',
      '#value' => t('Perform Training'),
      '#submit' => array('mltag_train_submit'),
      '#description' => t('<p>You can press this button to Train the model on your exisiting website content.</p><p>Training may take some time depending on the amount of website content.</p>'),
      
      );
  
  $status = '<br />You can press this button to Train the model on your exisiting website content.';
  $status .= ' Training may take some time depending on the amount of website content.';
  if ($num_rows > 0) {
    $status .=' <br /><u><b>Status</u> :</b> Model was last trained on: <b>' . $record->date_created . '</b> </p>';
  }
  else {
    $status .=' <p><u><b>Status</u> :</b> Model has not been trained till now. </p>';
  }
  $form['mytextcontainer']['status'] = array(
  '#markup' => t($status),
      
  );
  $form['mytextcontainer']['unpublished'] = array(
      '#type' => 'checkbox',
      '#title' => t('Use Unpublished Data for Training'),
      '#default_value' => variable_get('unpublished', TRUE),
      '#description' => t('Check this option to train the model using both Published & Unpublished content. Unchecking this option trains the model only on Published content.'),
      );
  
  if(module_exists('taxonomy')) {
  $vocabulary = array();
  $vocabulary = taxonomy_get_vocabularies();
  $checklist_vocab_array = array(); 
  foreach ($vocabulary as $item) {
    $checklist_vocab_array[$item->vid] = $item->name;
  }
  
  $form['user_vocab_list'] = array(
      '#type'             => 'checkboxes',
      '#title'            => t('Add terms to the Trained Model'),
      '#position'         => 'left' ,
      '#options'          => $checklist_vocab_array ,
      '#default_value'    => variable_get('user_vocab_list', FALSE),
      '#description'      => t('Users can add new terms explicitly to the Trained Model by choosing appropriate Vocabularies from above. These terms will be given higher weightage than those learned during Training'),
  );
  }

  $node_types = node_type_get_types();
  foreach ($node_types as $node_type) {
    $types[$node_type->type] = $node_type->name;
  }
  
  $form['mltag_node_types'] = array(
      '#type' => 'checkboxes',
      '#default_value' => variable_get('mltag_node_types', array('article')), 
      '#title' => t('Node Types'),
      '#options' => $types,
  );
  
  return system_settings_form($form);
}

function mltag_taxonomy_get_children_all($tid, $vid = 0, $key = 'tid'){
  $c = taxonomy_get_children($tid, $vid, $key);
  $result = array();
  foreach ($c as $t => $d){
    $result[$t] = $d;
    $below = taxonomy_get_children_all($t, $vid, $key);
    if (!empty($below)) {
      foreach ($below as $nt => $nd){
        $result[$nt] = $nd;
      }
    }
  }
  return $result;
}

function mltag_train_submit($form, &$form_state) {
  $form_state['redirect'] = 'admin/config/mltag/train'; 
}
function mltag_configure_train_confirm() {
  return confirm_form(array(), t('Are you sure you want to Train the model?'),
      'admin/config/mltag/settings', t('This action trains the model, and may be a lengthy process.'), t('Perform Training'), t('Cancel'));
}

function mltag_configure_train_confirm_submit($form, &$form_state) {
  if ($form_state['values']['confirm']) {
    mltag_train(); //function for training the past posts
    
  }
      
}
 /**
 *	@todo- place a check for minimum content length to be used for algo-2
 *  		and if content length is small use algo-1 instead
 *  Main training algorithm.
 *  @var array $tags_learned 
 *  		stores key as nid and value as array of tags
 *  @var array $tags_learned_array
 *  		stores all the implicit tags. key is word and value is it's chi square value
 *  @var $tags
 *  		 local var inside the while loop stores the implicit tags for the content
 *  @var $user_tags
 *  		 local var inside while loop stores the tags specified explicitly by the user  
 */
function mltag_train() {
  drupal_set_time_limit(180);
  module_load_include('inc', 'mltag', 'includes/content_tag');
  if(variable_get('unpublished')) {
    $query = db_select('node', 'n');
    $query
    ->fields('n', array('title', 'nid'))
    ->fields('f', array('body_value'))
    ->join('field_data_body', 'f', 'n.nid = f.entity_id');       
  }
  else {
  $query = db_select('node', 'n');
  $query
  ->fields('n', array('title', 'nid'))
  ->fields('f', array('body_value'))
  ->condition('n.status', '1')
  ->join('field_data_body', 'f', 'n.nid = f.entity_id');
  }
  $result = $query->execute();  
  $record = $result->fetchAll();
  $num_rows_content = $result->rowCount();
  if ($num_rows_content == 0 || $num_rows_content == NULL) {
    drupal_set_message(t('Error : Since there is no pre-existing content on this website, therefore, the model can not be trained.<br /> Please add some content to the website and try again.'), 'error');
  return;
  }
  
  //This selects the tags specified explicitly by the user for each node
  $query1 = db_select('taxonomy_index', 't');
  $query1
  ->fields('t', array('nid'))
  ->fields('data', array('name'))
  ->join('taxonomy_term_data', 'data', 't.tid = data.tid');
  $result1 = $query1->execute();
  $record1 = $result1->fetchAll(); 
  $num_rows_tags = $result1->rowCount();
  //drupal_set_message(print_r($record1, TRUE));
  //drupal_set_message($num_rows);
  
  //drupal_set_message(print_r($record1[3]->body_value, TRUE));
  
  $i = 0;
  $tags_learned = array();
  $tags_learned_array = array();
  while ($i<$num_rows_content) {
      //drupal_set_message(print_r($record["$i"]->title,TRUE));
  $content = '';
  $content .= $record["$i"]->title;
  $content = $content . ' ' . $record["$i"]->body_value;
  //call tagging algorithm and extract 10 tags for each content. $tags array stores the tags dervied using algo 2 for each content
  $tags = mltag_content_tag($content, 2, 10);
  //drupal_set_message(print_r($tags,TRUE));
  
  $tags_count = count($tags);
  if ($tags_count < 10) {
    $diff = 10 - $tags_count;
    $tags_extra = array();
    $tags_extra = mltag_content_tag($content, 1, $diff);
    $tags = array_merge($tags, $tags_extra);
  }
  
  // user_tags stores the explicit tags for content  
  $user_tags = array();
  $temp_count = 0;
  while ($temp_count < $num_rows_tags) {
    $nid1 = $record["$i"]->nid;
    $nid2 = $record1["$temp_count"]->nid;
    if ( $nid1 == $nid2 ) {
      $user_tags[] = $record1["$temp_count"]->name;
    } 
    $temp_count++;
  }
  
  //drupal_set_message(print_r($user_tags,TRUE));
  
  
  $nid = $record["$i"]->nid;
  $user_tags = array_flip($user_tags);
  //$tags = array_merge($tags, $temp);
  //drupal_set_message(print_r($tags,TRUE));
  $tags_learned["$nid"] = $tags;
  $timestamp = date('Y-m-d G:i:s');
  
  db_merge('mltag_learn_tags')
    ->key(array('nid' => $nid ))
    ->fields(array('content_tags' => serialize($tags), 'user_tags' => serialize($user_tags), 'date_created' => $timestamp))
    ->execute();
  
  
  $i++;
  }
  
  //make function end here
 mltag_rank_terms($tags_learned);
 $status = "The model has been trained successfully using $num_rows_content node contents existing on this website. ";
 drupal_set_message(check_plain($status), 'status');
 
}
  
  /**
   * Ranking chi values using z-score method.
   * The z-score of any one criterion 
   * is calculated as = (actual value – mean of criterion)/standard deviation of criterion. 
   * 
   */
function mltag_rank_terms($tags_learned) {
  $count = 0;
  $tags_learned_array = array();  
  foreach ($tags_learned as $nid => $array) {
      
    $tags_learned_array = mltag_merge_array($tags_learned_array, $array);
  }
  //drupal_set_message(print_r($tags_learned_array, TRUE));
   
  $sum = 0;
  
  foreach ($tags_learned_array as $word => $chi) {
      $sum += $chi;
  }

  $mean = $sum / count($tags_learned_array);
  $sd = mltag_sd($tags_learned_array);
  $ranked_tags = array();
  foreach ($tags_learned_array as $word => $chi) {
    $ranked_tags["$word"] = round((($chi - $mean) / $sd), 4); 
    
  } 
  arsort($ranked_tags);
  //$ranked_tags contain tags ranked using z-score 
  $file = drupal_get_path("module", "mltag") . '/includes/learned_tags.txt';
  file_put_contents($file, urlencode(serialize($ranked_tags)));
  //$content2 = file_get_contents($file);
  //$arr = unserialize(urldecode($content2));
  /*
  drupal_set_message(print_r($ranked_tags, TRUE));
  drupal_set_message(print_r($sd, TRUE));
  drupal_set_message(print_r($mean, TRUE));
    */
}

/**
 * Function to calculate square of value - mean
 */ 
function mltag_sd_square($x, $mean) {
  return pow($x - $mean, 2);
}
/**
 * 
 * Function to calculate standard deviation (uses sd_square)
 */ 
function mltag_sd($array) {

  // square root of sum of squares devided by N-1
  return sqrt(array_sum(array_map("mltag_sd_square", $array, array_fill(0, count($array), (array_sum($array) / count($array)) ) ) ) / (count($array)-1) );
}
/**
 * Function to merge trained vocabulary arrays.
 * If on merge duplicate keys(tags or words) are encountered then the one having the maximum value( chi value) is chosen
 * in the final merged array.
 */
function mltag_merge_array($base, $sec) {
  $numargs = func_num_args();
  //echo "<h1>".$numargs."</h2>";
  for ($j=1; $j<($numargs); $j++) {
    $m=0;
    $max = array();
    $sec= func_get_arg($j);
    if (empty($base)) {
      $base = $sec;
      return $base;
    }
    foreach ($base as $base_key => $base_val) {
    
    foreach ($sec as $sec_key => $sec_val) {
      

        if ($base_key === $sec_key) {
        
        $m = max($base_val, $sec_val);
        $max[$base_key] = $m;
        }
        
        else {
          $base[$sec_key] = $sec_val;
        }
      }
    }

    foreach ($max as $mkey => $mvalue) {
      
        $base[$mkey] = $mvalue;
    }
    
    unset($max);
  }
    return $base;
}

/**
 * Implementation of stopwords settings page
 */

function mltag_stopwords_settings() {
  
  $form['stopwords_textfield'] = array(
    '#type' => 'textarea',
    '#cols' => 30,
    '#rows' => 10,
    '#title' => t('Stop Words'),
    '#description' => t('Stop Words removed during parsing of text'),
    '#default_vale' => variable_get('stopwords_textfield'),             
  );
  return system_settings_form($form);
}

